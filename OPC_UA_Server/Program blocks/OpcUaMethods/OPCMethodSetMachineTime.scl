FUNCTION_BLOCK "OPCMethodSetMachineTime"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      OPC_UA_ServerMethodPre_Instance {InstructionName := 'OPC_UA_ServerMethodPre'; LibVersion := '1.0'} : OPC_UA_ServerMethodPre;
      statUAMStatusPre : "typeOPCUAStatus";
      statUAMStatusPost : "typeOPCUAStatus";
      UAMethod_InParameters : Struct
         DateTime : LDT;
      END_STRUCT;
      OPC_UA_ServerMethodPost_Instance {InstructionName := 'OPC_UA_ServerMethodPost'; LibVersion := '1.0'} : OPC_UA_ServerMethodPost;
   END_VAR

   VAR_TEMP 
      tempUAMMethodHandling : "typeOPCUAMethodHandling";
      tempIntReturnOfSysTime : Int;
   END_VAR

   VAR CONSTANT 
      NO_ERROR : Int := 16#0000;
      ERROR_IN_DATE : Int := 16#8080;
      ERROR_IN_TIME : Int := 16#8081;
      REAL_TIME_CLOCK_FAILED : Int := 16#80B0;
   END_VAR


BEGIN
	//=============================================================================
	// Siemens// (c)Copyright (2017)
	//-----------------------------------------------------------------------------
	// Library: -
	// Tested with: CPU:-  FW:-
	// Engineering: TIA Portal (inc 25)
	// Restrictions: -
	// Requirements: OPCUA Server activated, Fimware V2.5
	// Functionality: sets the machine time to a userdefined value.
	//-----------------------------------------------------------------------------
	// Change log table:
	// Version Date Expert in charge Changes applied
	// 04.12.2017 dd.mm.yyyy (APC ERLF) First released version //=============================================================================
	REGION INIT Temp
	    #tempIntReturnOfSysTime := 0;
	    #tempUAMMethodHandling.Called := FALSE;
	    #tempUAMMethodHandling.Finished := FALSE;
	    #tempUAMMethodHandling.Result := "OpcUa_Good";
	END_REGION
	
	REGION PRE
	    #OPC_UA_ServerMethodPre_Instance(Done => #statUAMStatusPre.done,
	                                     Busy => #statUAMStatusPre.busy,
	                                     Error => #statUAMStatusPre.error,
	                                     Status => #statUAMStatusPre.status,
	                                     UAMethod_Called => #tempUAMMethodHandling.Called,
	                                     UAMethod_InParameters := #UAMethod_InParameters);
	END_REGION
	
	REGION FUNCTIONALITY
	    IF #tempUAMMethodHandling.Called THEN
	        #tempIntReturnOfSysTime := WR_SYS_T(#UAMethod_InParameters.DateTime);
	        
	        //ERROR Generation and handling
	        IF #tempIntReturnOfSysTime = #NO_ERROR THEN
	             #tempUAMMethodHandling.Result := "OpcUa_Good";
	        ELSIF #tempIntReturnOfSysTime = #ERROR_IN_DATE THEN
	            #tempUAMMethodHandling.Result := "OpcUa_BadSyntaxError";
	        ELSIF #tempIntReturnOfSysTime = #ERROR_IN_TIME THEN
	            #tempUAMMethodHandling.Result := "OpcUa_BadSyntaxError";
	        ELSIF #tempIntReturnOfSysTime = #REAL_TIME_CLOCK_FAILED THEN
	            #tempUAMMethodHandling.Result := "OpcUa_BadInternalError";
	        END_IF;
	        //SET METHOD TO DONE
	        #tempUAMMethodHandling.Finished := TRUE;
	    END_IF;
	END_REGION
	
	
	REGION Post
	    #OPC_UA_ServerMethodPost_Instance(UAMethod_Result := #tempUAMMethodHandling.Result,
	                                      UAMethod_Finished := #tempUAMMethodHandling.Finished,
	                                      Done => #statUAMStatusPost.done,
	                                      Busy => #statUAMStatusPost.busy,
	                                      Error => #statUAMStatusPost.error,
	                                      Status => #statUAMStatusPost.status);
	END_REGION
END_FUNCTION_BLOCK

